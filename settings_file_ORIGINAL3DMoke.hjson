{
	/* 
	loop tuning parameters get passed straight to the main moke instrument and 
	are used in the magnet loop tuning experiment for PID loop tuning. 
	So far, I found that just P correction is better for the type of tuning that we are doing
	*/
	"loop_tuning":{
		"Kp": 1.8,
		// "Kp": 0.3,
		// "Ki": 0.2,
		// "Kd": 0.8
	},
	"controllers": [
		{
			"type": "NIcardRTSI",
			"name": "NIcard",
			"parameters": {
				/* The rate of the device.
				This needs to be divisible by 5 due to the way timing is done
				*/
				"rate": 10000,
				/* NI input buffer size in number of samples. 
				This should be increased if the system can't keep up with the acquisition
				*/
				"input_buffer_size": 200000,
				/* How often the data is read from the inputs. 
				This should never be bigger than the clock master tick rate (0.1 by default)
				*/
				"data_acquisition_period": 0.05
				/* How often are the outputs refreshed
				*/
				"output_refresh_time": 0.05
				/*
				The order of these entries determines the order the card reads the data. 
				This is important for current leakages.
				*/
				"ports": {
					"AI": [
						# hallprobe
						"Dev1/ai21",
			            "Dev1/ai20",
			            "Dev1/ai19",
			            # bighall fields
			            "Dev1/ai4",
			            "Dev1/ai5",
			            "Dev1/ai6",
			            # bighall temp
			            "Dev1/ai7",
		            	# reference
			            "Dev1/ai23",
			            # temperature
			            "Dev1/ai17",
			            "Dev1/ai16",
			            "Dev1/ai18",
			            # wollaston 1
			            "Dev1/ai0",
			            "Dev1/ai1",
		            	# wollaston 2
			            "Dev1/ai2",
			            "Dev1/ai3"
						# clock
						"Dev1/ai22"

					],
					"AO": [
						# reference
			            "Dev1/ao2"
						# laser
			            "Dev1/ao3"
						# hexapole
						"Dev2/ao0",
						"Dev2/ao2",
						"Dev2/ao4",
						# clock
						"Dev2/ao11"
					]
				}
			}
		},

		{
			"type": "SmaractControl",
			"name": "SmaractController",
			# buffer time given between commands
			"parameters": {
				"locator":"usb:sn:MCS2-00003775"
			},
		}
		{
			"type": "CameraControl",
			"name": "CameraController"
			"parameters": {
				"class_name": "UC480_Camera",
				"id": 1
			}
		}
		{
			"type": "CameraControl",
			"name": "CameraController2"
			"parameters": {
				"class_name": "UC480_Camera",
				"id": 2
			}
		}
	],
	"instruments": {
		"hallprobe":{
			"type": "NIinst",
			"port_type": "AI",
			"controller": "NIcard",
			"ports": {
				"Dev1/ai21": "hallprobe_A",
	            "Dev1/ai20": "hallprobe_B",
	            "Dev1/ai19": "hallprobe_C"
			},
			// "calibration": {
			// 	"type": "NIoffsetScale",
			// 	"parameters": {
			// 		# volts in HPs to mT in table reference frame
			// 		"scale":[[27.26, 0, 0],
			// 				[0, 27.26, 0],
			// 				[0, 0, 27.26]],
			// 	},
			// }
			"calibration": {
				"type": "HPSampleCalib",
				"parameters": {
					# volts in HPs to mT in table reference frame
					"scale":        [[-19.85840144,   9.29552093,  10.497066 ],[-14.32594331, -14.29069812, -14.87641308],[ -0.17593562, -15.91545309,  15.03925804]]
				},
				"subinstruments": "stage"
			}
		},
		"hexapole": {
			"type": "NIinst",
			"port_type": "AO",
			"controller": "NIcard",
			"ports": {
	            "Dev2/ao0": "magnet_A",
	            "Dev2/ao2": "magnet_B",
	            "Dev2/ao4": "magnet_C"
			},
			//  "calibration": {
			//  	"type": "SampleFieldsCalib",
			//  	"parameters": {
			//  		"zero_angle": 0
			//  	}
			//  	"subinstruments": "stage"
			//  }

			"calibration": {
				"type": "MagnetHystCalib",
				"parameters": {
					# file where the fitting parameters are stored
					"file_path": "C:\\Users\\3Dstation3\\PycharmProjects\\pythonProject\\data\\magnet_response_parameters_hyst.p",
					# kepco mode, can be current or voltage
					"kepco_mode" : "current"
				}
				"subinstruments": "hallprobe" # needs a hallprobe for a subinstrument to adjust for its calibration!
			}
			/*
			 Creates the feedback class. For this to work, a compatible calibration also needs to be used,
			 with data2inst function outputting the output signal as well as the feedback setpoint
			 Possible parameters are: #
				type - type of the feedback class contianing functions to calculate corrections
			 	input_instrument - instrument which is collecting the input signal
				parameters - parameters of the feedback class
				Any additional parameters get passed to the feedback class as keyword arguments
			 */
			# "feedback": {
			# 	"type": "PIDfeedback",
			# 	"input_instruments": "hallprobe",
			# 	"parameters": {
			# 		"Kp": 0.02, # feedback coefficient
			# 		"Ki": 0.5, # integration coefficient
			# 		"Kd": 1, # differentiation coefficient
			# 	}
			# }
		},

		"reference":{
			"type": "NIinst",
			"port_type": "AO",
			"controller": "NIcard",
			"ports": {
	            "Dev1/ao2": "reference"
			},
			"calibration": {
				"type":"Reference",
				"parameters": {
					"offset": 2.45
				}
			}
		},
		"laser":{
			"type": "NIinst",
			"port_type": "AO",
			"controller": "NIcard",
			"ports": {
	            "Dev1/ao3": "laser"
			}
		},
		"temperature":{
			"type": "NIinst",
			"port_type": "AI",
			"controller": "NIcard",
			"ports": {
	            "Dev1/ai18": "temperature_A",
	            "Dev1/ai17": "temperature_B",
	            "Dev1/ai16": "temperature_C"
			},
			"calibration": {
				"type": "TemperatureCalibration",
				"parameters": {
					"offset": 812,
					"scale": 23
				}
			},
			"subsample": 10
		},
		"wollaston1":{
			"type": "NIinst",
			"port_type": "AI",
			"controller": "NIcard",
			"ports": {
	            "Dev1/ai0": "det1",
	            "Dev1/ai1": "det2"
			},
			"calibration": "default"
		},
		"wollaston2":{
			"type": "NIinst",
			"port_type": "AI",
			"controller": "NIcard",
			"ports": {
	            "Dev1/ai2": "det1",
	            "Dev1/ai3": "det2"
			},
			"calibration": "default"
		},

		"bighall_fields":{
			"type": "NIinst",
			"port_type": "AI",
			"controller": "NIcard",
			"ports": {
	            "Dev1/ai4": "x",
	            "Dev1/ai5": "y",
	            "Dev1/ai6": "z"
			},
			"calibration": {
				"type": "NIoffsetScale",
				"parameters": {
					# volts to mT
					'scale': [[-20, 0, 0], [0, 0, 20], [0, 20, 0]],
					'offset': [0, 0, 0]
				}
			}
		},

		"bighall_temp":{
			"type": "NIinst",
			"port_type": "AI",
			"controller": "NIcard",
			"ports": {
	            "Dev1/ai7": "temp"
			},
			"calibration": {
				"type": "NIoffsetScale",
				"parameters": {
					# volts to C
					'scale': 0.5,
					'offset': 25
				}
			},
			"subsample": 1
		},

		"stage":{
			"type":"Smaract",
			"controller":"SmaractController",
			"axes":{
				"x":1,
				"y":2,
				"z":0,
				"phi":3
			}, #mapping axis name to channel
			// if left blank, uses the max speed allowed by the closed loop frequency
			 "velocity":[
			 	100000000, #speed in pm/s
			 	100000000, #speed in pm/s
			 	100000000, #speed in pm/s
			 	2000000000, #speed in ndeg/s
			]
			"calibration": {
				// "type": "SmaractScaleCalib",
				"type": "SmaractSampleCalib",
				"parameters": {
					"scale": [
						1000000,
						1000000,
						1000000,
						-1000000000
					]
				}
			}
		},

		"camera1":{
			"type": "Camera",
			"controller": "CameraController",
			# framerate in Hz
			"framerate": 30,
			# exposure time in s
			"exposure_time": 0.02,
			#automatic subsampling of the pixels in horisontal and vertical directions
			#(native resolution is 1280x1024 and running two cameras simultaneously at full resolution can slow down plotting slightly)
			"hsub": 2,
			"vsub": 2,
			"calibration": "default"
		},
		"camera2": {
			"type": "Camera",
			"controller": "CameraController2",
			# framerate in Hz
			"framerate": 30,
			# exposure time in s
			"exposure_time": 0.03,
			#automatic subsampling of the pixels in horisontal and vertical directions
			#(native resolution is 1280x1024 and running two cameras simultaneously at full resolution can slow down plotting slightly)
			"hsub": 2,
			"vsub": 2,
			"calibration": "default"
		}
	}
}

